#python REFINED.py data/normalized_padel_feats_NCI60_672_small.csv res 1 0 10
from sys import argv
# [name, dataset_path, saving_path, iters_count, first, last]

if len(argv) < 6:
    print("Not enought args\nPlease input: dataset path, saving path, count of hill climb iterations, first index, last index")
    exit()

dataset_filename, path, iters_count, first, last = argv[1:]
iters_count = int(iters_count)
first = int(first)
last = int(last)

import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt
from Toolbox import two_d_eq, Assign_features_to_pixels
from sklearn.manifold import MDS
from sklearn.metrics.pairwise import euclidean_distances
import math
from itertools import product
import paraHill
from Toolbox import REFINED_Im_Gen


Feat_DF = pd.read_csv(dataset_filename)     #"data/normalized_padel_feats_NCI60_672_small.csv"
X = Feat_DF.values
X = X[first:last+1]
original_input = pd.DataFrame(data = X)

feature_names_list = Feat_DF.columns.tolist()
nn = math.ceil(np.sqrt(len(feature_names_list)))      			     # Image dimension
Nn = original_input.shape[1]                                         # Number of features
transposed_input = original_input.T 							     # The MDS input data must be transposed , because we want summarize each feature by two values (as compard to regular dimensionality reduction each sample will be described by two values)
Euc_Dist = euclidean_distances(transposed_input) 					 # Euclidean distance
Euc_Dist = np.maximum(Euc_Dist, Euc_Dist.transpose())   			 # Making the Euclidean distance matrix symmetric
embedding = MDS(n_components=2)										 # Reduce the dimensionality by MDS into 2 components
mds_xy = embedding.fit_transform(transposed_input)					 # Apply MDS


eq_xy = two_d_eq(mds_xy,Nn) # -> [0,1]
Img = Assign_features_to_pixels(eq_xy,nn,verbose=0)					# Img is the none-overlapping coordinates generated by MDS
Dist = pd.DataFrame(data = Euc_Dist, columns = feature_names_list, index = feature_names_list)	# Generating a distance matrix which includes the Euclidean distance between each and every descriptor




# Convert from 'F34' to int 34
init_map = np.char.strip(Img.astype(str),'F').astype(int)
map_in_int = init_map



for iter_num in range(iters_count):
    init_coords = [x for x in product([0,1,2],repeat = 2)]
    for init_coord in init_coords:
        # generate the centroids
        xxx = [init_coord[0]+i*3 for i in range(int(nn/3)+1) if (init_coord[0]+i*3)<nn]
        yyy = [init_coord[1]+i*3 for i in range(int(nn/3)+1) if (init_coord[1]+i*3)<nn]
        centr_list = [x for x in product(xxx,yyy)]
        swap_dict = paraHill.evaluate_centroids_in_list(centr_list,Dist,map_in_int)
        # print(swap_dict)
        map_in_int = paraHill.execute_dict_swap(swap_dict, map_in_int)

        # print(">",init_coord,"Corr:",paraHill.universial_corr(Dist,map_in_int))


coords = np.array([[item[0] for item in np.where(map_in_int == ii)] for ii in range(Nn)])

X_REFINED_MDS = REFINED_Im_Gen(X[:,:],nn, map_in_int, feature_names_list, coords)


X_reshaped = X_REFINED_MDS.reshape(X_REFINED_MDS.shape[0], nn, nn)
if not os.path.exists(path):
    os.mkdir(path)
for i in range(X_reshaped.shape[0]):
    plt.imsave(f"""{path}/img{i}.png""", X_reshaped[i])




